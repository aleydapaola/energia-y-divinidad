// Prisma Schema para Energía y Divinidad
// Arquitectura: Bounded Contexts + Entitlements para acceso a contenido

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// BOUNDED CONTEXT: User Management
// ============================================

enum UserRole {
  USER
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String? // Para autenticación con email/password
  role          UserRole  @default(USER)

  // Consentimiento legal
  acceptedTermsVersion String?   // Versión de términos aceptados (ej: "1.0")
  acceptedTermsAt      DateTime? // Fecha y hora de aceptación

  // Relaciones
  accounts         Account[]
  sessions         Session[]
  orders           Order[]
  subscriptions    Subscription[]
  entitlements     Entitlement[]
  bookings         Booking[]
  seatAllocations  SeatAllocation[]
  waitlistEntries  WaitlistEntry[]
  sessionPackCodes SessionPackCode[]
  postLikes        MembershipPostLike[]
  postComments     MembershipPostComment[]
  commentLikes     CommentLike[]
  pollVotes        PollVote[]
  postViews        MembershipPostView[]
  courseProgress   CourseProgress[]
  creditsLedger    CreditsLedger[]
  quizAttempts     QuizAttempt[]
  certificates     Certificate[]
  perkAllocations  PerkAllocation[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

// NextAuth - Account (para OAuth providers)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

// NextAuth - Session
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

// NextAuth - Verification Token
model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

// ============================================
// BOUNDED CONTEXT: Payments & Orders
// ============================================

enum PaymentMethod {
  // Wompi (Colombia - COP)
  WOMPI_NEQUI
  WOMPI_CARD
  WOMPI_PSE
  WOMPI_MANUAL // Link de pago genérico (pago puntual, no recurrente)

  // PayPal (Internacional y Colombia - USD y COP)
  PAYPAL_DIRECT
  PAYPAL_CARD

  // Bre-B (Colombia - pago manual con QR/llave)
  BREB_MANUAL

  // Gratis (descuento 100%)
  FREE

  // LEGACY - mantener para datos históricos, no usar para nuevos pagos
  STRIPE
  NEQUI
  MANUAL_NEQUI
  MANUAL_DAVIPLATA
  MANUAL_BANCOLOMBIA
  EPAYCO_CARD
  EPAYCO_PAYPAL
  EPAYCO_PSE
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum OrderType {
  PRODUCT
  SESSION
  EVENT
  MEMBERSHIP
  PREMIUM_CONTENT
  COURSE
}

model Order {
  id          String  @id @default(cuid())
  userId      String?
  orderNumber String  @unique // Generado: ORD-YYYYMMDD-XXXX

  // Guest checkout - email cuando no hay usuario autenticado
  guestEmail String?
  guestName  String?

  // Tipo y referencia
  orderType OrderType
  itemId    String // ID del producto/sesión/evento en Sanity o ID de membership tier
  itemName  String

  // Montos
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("COP") // COP o USD

  // Descuentos (opcional)
  discountCodeId String?  // Sanity _id del código de descuento
  discountCode   String?  // Código usado (para histórico)
  discountAmount Decimal? @db.Decimal(10, 2) // Monto descontado
  originalAmount Decimal? @db.Decimal(10, 2) // Monto original antes del descuento

  // Pago
  paymentMethod PaymentMethod
  paymentStatus PaymentStatus @default(PENDING)

  // Metadata adicional (JSON para datos específicos de pasarela)
  metadata Json?

  // Relaciones
  user          User?          @relation(fields: [userId], references: [id])
  manualPayment ManualPayment?
  stripePayment StripePayment?
  entitlements  Entitlement[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("orders")
}

// Pagos manuales (Nequi, Daviplata, Bancolombia)
model ManualPayment {
  id      String @id @default(cuid())
  orderId String @unique

  // Detalles del pago
  paymentMethod   PaymentMethod
  referenceNumber String? // Número de transacción proporcionado por el usuario
  screenshot      String? // URL del screenshot de comprobante

  // Aprobación manual
  approved       Boolean   @default(false)
  approvedAt     DateTime?
  approvedBy     String? // Admin user ID
  rejectedReason String?

  // Relaciones
  order Order @relation(fields: [orderId], references: [id])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("manual_payments")
}

// LEGACY - Mantener para datos históricos de pagos con Stripe
// No se crean nuevos registros desde que Stripe fue deprecado
model StripePayment {
  id      String @id @default(cuid())
  orderId String @unique

  // IDs de Stripe
  stripePaymentIntentId String  @unique
  stripeCustomerId      String?

  // Detalles
  amount   Decimal @db.Decimal(10, 2)
  currency String
  status   String // Stripe payment intent status

  // Webhook idempotency
  webhookProcessed Boolean @default(false)
  webhookId        String? @unique

  // Relaciones
  order Order @relation(fields: [orderId], references: [id])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("stripe_payments")
}

// ============================================
// BOUNDED CONTEXT: Memberships
// ============================================

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELLED
  EXPIRED
  TRIAL
}

enum BillingInterval {
  MONTHLY
  YEARLY
}

model Subscription {
  id     String @id @default(cuid())
  userId String

  // Membership tier (referencia a Sanity)
  membershipTierId   String // ID del documento en Sanity
  membershipTierName String

  // Billing
  status          SubscriptionStatus
  billingInterval BillingInterval
  amount          Decimal            @db.Decimal(10, 2)
  currency        String             @default("COP")
  paymentProvider String             @default("stripe") // "stripe" | "nequi" | "manual"

  // LEGACY - Stripe (mantener para suscripciones históricas)
  stripeSubscriptionId String? @unique
  stripeCustomerId     String?

  // Nequi (si aplica)
  nequiSubscriptionId String? @unique // ID de suscripción de Nequi API
  nequiPhoneNumber    String? // Número de celular registrado en Nequi
  nequiApprovedAt     DateTime? // Cuando el usuario aprobó en la app Nequi

  // Fechas
  startDate          DateTime
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  trialEnd           DateTime?
  cancelledAt        DateTime?

  // Relaciones
  user         User          @relation(fields: [userId], references: [id])
  entitlements Entitlement[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("subscriptions")
}

// ============================================
// BOUNDED CONTEXT: Entitlements (Access Control)
// ============================================

enum EntitlementType {
  MEMBERSHIP // Acceso a membresía
  PREMIUM_CONTENT // Acceso a contenido premium específico
  EVENT // Acceso a evento
  SESSION_BUNDLE // Paquete de sesiones
  PRODUCT // Producto digital comprado
  COURSE // Curso de la academia
}

model Entitlement {
  id     String @id @default(cuid())
  userId String

  // Tipo y referencia
  type         EntitlementType
  resourceId   String // ID en Sanity del recurso
  resourceName String

  // Orden relacionada
  orderId        String?
  subscriptionId String?

  // Validez
  expiresAt     DateTime? // null = permanente
  revoked       Boolean   @default(false)
  revokedAt     DateTime?
  revokedReason String?

  // Para session bundles
  sessionsTotal Int? // Total de sesiones en el paquete
  sessionsUsed  Int? @default(0)

  // Relaciones
  user         User          @relation(fields: [userId], references: [id])
  order        Order?        @relation(fields: [orderId], references: [id])
  subscription Subscription? @relation(fields: [subscriptionId], references: [id])

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId, type])
  @@index([userId, resourceId])
  @@map("entitlements")
}

// ============================================
// BOUNDED CONTEXT: Bookings (Sesiones y Eventos)
// ============================================

enum BookingType {
  SESSION_1_ON_1
  EVENT
}

enum BookingStatus {
  PENDING_PAYMENT // Esperando pago
  PENDING // Esperando confirmación
  CONFIRMED // Confirmada
  CANCELLED // Cancelada por usuario
  COMPLETED // Completada
  NO_SHOW // Usuario no apareció
}

model Booking {
  id     String @id @default(cuid())
  userId String

  // Tipo y referencia
  bookingType  BookingType
  resourceId   String // ID en Sanity (session o event)
  resourceName String

  // Fecha y hora
  scheduledAt DateTime?
  duration    Int? // Duración en minutos

  // Status
  status BookingStatus @default(PENDING)

  // Payment info
  amount        Decimal?       @db.Decimal(10, 2)
  currency      String?        @default("COP")
  paymentMethod PaymentMethod?
  paymentStatus PaymentStatus? @default(PENDING)

  // Session pack info
  sessionsTotal     Int? // Total de sesiones en el paquete
  sessionsRemaining Int? // Sesiones restantes

  // LEGACY - Stripe payment (mantener para bookings históricos)
  stripeSessionId String? @unique

  // Nequi payment (if applicable)
  nequiTransactionCode String? // Código único de transacción
  nequiQrCode          String? @db.Text // QR code para pago (modo gateway)
  nequiPaymentId       String? // ID de pago de Nequi API

  // Entitlement (si fue pagado)
  entitlementId String?

  // Formulario de ingreso (para sesiones 1:1)
  intakeFormData Json? // Respuestas del formulario

  // Notas
  userNotes  String? @db.Text
  adminNotes String? @db.Text

  // Cancelación
  cancelledAt        DateTime?
  cancellationReason String?

  // Reprogramación
  previousScheduledAt DateTime? // Fecha anterior (antes de reprogramar)
  rescheduledAt       DateTime? // Cuándo se reprogramó
  rescheduledBy       String?   // userId de quien reprogramó (null = cliente, id = admin)
  rescheduleCount     Int       @default(0) // Veces que se ha reprogramado
  rescheduleReason    String?   // Motivo de la última reprogramación

  // Relaciones
  user User @relation(fields: [userId], references: [id])

  // Metadata adicional
  metadata Json?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([scheduledAt])
  @@map("bookings")
}

// ============================================
// BOUNDED CONTEXT: Event Seat Management
// ============================================

enum SeatAllocationStatus {
  ACTIVE   // Seat is confirmed and occupied
  RELEASED // Seat was released (cancellation)
}

model SeatAllocation {
  id        String @id @default(cuid())
  eventId   String // Sanity event _id
  bookingId String @unique
  userId    String
  seats     Int    @default(1) // Number of seats in this allocation

  status SeatAllocationStatus @default(ACTIVE)

  // Timestamps
  allocatedAt DateTime  @default(now())
  releasedAt  DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@index([eventId])
  @@index([userId])
  @@index([eventId, status])
  @@map("seat_allocations")
}

enum WaitlistStatus {
  WAITING       // In queue waiting for spot
  OFFER_PENDING // Spot offered, waiting for acceptance
  ACCEPTED      // User accepted, becoming booking
  DECLINED      // User declined the offer
  EXPIRED       // Offer expired without response
  CANCELLED     // User cancelled their waitlist entry
}

model WaitlistEntry {
  id      String @id @default(cuid())
  eventId String // Sanity event _id
  userId  String

  // Queue management
  position       Int // Position in waitlist (1-based)
  seatsRequested Int @default(1)

  status WaitlistStatus @default(WAITING)

  // Offer lifecycle
  offerSentAt    DateTime?
  offerExpiresAt DateTime?
  reminderSentAt DateTime? // For 6h reminder email
  respondedAt    DateTime?

  // When accepted, links to the created booking
  resultingBookingId String?

  // Contact info (copied at creation time for notifications)
  userEmail String
  userName  String?

  // Metadata
  notes String? @db.Text

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@unique([eventId, userId]) // One entry per user per event
  @@index([eventId, status])
  @@index([eventId, position])
  @@index([offerExpiresAt])
  @@map("waitlist_entries")
}

// ============================================
// BOUNDED CONTEXT: Event Replay Views
// ============================================

// Tracking de visualizaciones de replays de eventos
model EventReplayView {
  id                  String   @id @default(cuid())
  bookingId           String   @unique // Un registro por booking
  eventId             String   // Sanity event _id (denormalizado para queries)
  userId              String   // Denormalizado para queries

  // Métricas de visualización
  viewCount           Int      @default(1)  // Veces que inició el replay
  totalWatchedSeconds Int      @default(0)  // Segundos totales vistos
  lastWatchedAt       DateTime @default(now())
  lastPosition        Int      @default(0)  // Posición para continuar (segundos)

  // Timestamps
  firstViewedAt       DateTime @default(now())
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  @@index([userId])
  @@index([eventId])
  @@index([eventId, userId])
  @@map("event_replay_views")
}

// ============================================
// BOUNDED CONTEXT: Session Pack Codes
// ============================================

model SessionPackCode {
  id     String @id @default(cuid())
  userId String

  // Código único para canjear sesiones
  code String @unique // Formato: PACK-XXXXXX

  // Info del pack
  packName        String  @default("Pack de 8 Sesiones")
  sessionsTotal   Int     @default(8)
  sessionsUsed    Int     @default(0)
  priceAtPurchase Decimal @db.Decimal(10, 2)
  currency        String  @default("COP")

  // Estado
  active    Boolean   @default(true)
  expiresAt DateTime? // null = no expira

  // Booking relacionado (la compra original)
  originalBookingId String? @unique

  // Relaciones
  user            User              @relation(fields: [userId], references: [id])
  redemptions     PackRedemption[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([code])
  @@map("session_pack_codes")
}

model PackRedemption {
  id        String @id @default(cuid())
  packCodeId String
  bookingId  String @unique

  // Relaciones
  packCode SessionPackCode @relation(fields: [packCodeId], references: [id])

  // Metadata
  redeemedAt DateTime @default(now())

  @@index([packCodeId])
  @@map("pack_redemptions")
}

// ============================================
// BOUNDED CONTEXT: Membership Posts (Engagement)
// ============================================

// Modelo para tracking de publicaciones de membresía (sincronizado con Sanity)
model MembershipPost {
  id       String @id @default(cuid())
  sanityId String @unique // _id del documento en Sanity
  slug     String @unique

  // Engagement
  likes     MembershipPostLike[]
  comments  MembershipPostComment[]
  views     MembershipPostView[]
  pollVotes PollVote[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([sanityId])
  @@index([slug])
  @@map("membership_posts")
}

// Likes en publicaciones de membresía
model MembershipPostLike {
  id     String @id @default(cuid())
  userId String
  postId String

  // Relaciones
  user User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  post MembershipPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Metadata
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@index([postId])
  @@map("membership_post_likes")
}

// Comentarios en publicaciones de membresía
model MembershipPostComment {
  id      String @id @default(cuid())
  userId  String
  postId  String
  content String @db.Text

  // Relaciones
  user  User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  post  MembershipPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  likes CommentLike[]

  // Metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([userId])
  @@map("membership_post_comments")
}

// Likes en comentarios
model CommentLike {
  id        String @id @default(cuid())
  userId    String
  commentId String

  // Relaciones
  user    User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment MembershipPostComment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  // Metadata
  createdAt DateTime @default(now())

  @@unique([userId, commentId])
  @@index([commentId])
  @@map("comment_likes")
}

// Votos en encuestas
model PollVote {
  id          String @id @default(cuid())
  userId      String
  postId      String
  optionIndex Int // Índice de la opción votada en el array pollOptions

  // Relaciones
  user User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  post MembershipPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Metadata
  createdAt DateTime @default(now())

  @@unique([userId, postId]) // Un usuario solo puede votar una vez por encuesta
  @@index([postId])
  @@map("poll_votes")
}

// Vistas de publicaciones (para analytics)
model MembershipPostView {
  id     String  @id @default(cuid())
  userId String? // Puede ser null si es vista anónima
  postId String

  // Relaciones
  user User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  post MembershipPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Metadata
  createdAt DateTime @default(now())

  @@index([postId])
  @@index([userId])
  @@map("membership_post_views")
}

// ============================================
// BOUNDED CONTEXT: Webhooks (Idempotency)
// ============================================

model WebhookEvent {
  id String @id @default(cuid())

  // Proveedor
  provider  String // "stripe", "other"
  eventId   String @unique // ID del webhook del proveedor
  eventType String // Tipo de evento

  // Procesamiento
  processed   Boolean   @default(false)
  processedAt DateTime?

  // Payload
  payload Json

  // Error handling
  failed       Boolean @default(false)
  errorMessage String? @db.Text
  retryCount   Int     @default(0)

  // Metadata
  createdAt DateTime @default(now())

  @@index([provider, eventId])
  @@map("webhook_events")
}

// ============================================
// BOUNDED CONTEXT: Academia (Courses)
// ============================================

// Tracking de uso de códigos de descuento (el código está en Sanity)
model DiscountUsage {
  id             String   @id @default(cuid())
  discountCodeId String   // Sanity _id del código
  discountCode   String   // Código usado (para histórico)
  userId         String
  orderId        String
  discountAmount Decimal  @db.Decimal(10, 2)
  currency       String
  usedAt         DateTime @default(now())

  @@unique([discountCodeId, orderId])
  @@index([userId])
  @@index([discountCodeId])
  @@map("discount_usages")
}

// Progreso del usuario en un curso
model CourseProgress {
  id                   String           @id @default(cuid())
  userId               String
  courseId             String           // Sanity course _id
  startedAt            DateTime         @default(now())
  completedAt          DateTime?
  lastAccessedAt       DateTime         @default(now())
  completionPercentage Decimal          @db.Decimal(5, 2) @default(0)

  // Relaciones
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  lessonProgress LessonProgress[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, courseId])
  @@index([userId])
  @@index([courseId])
  @@map("course_progress")
}

// Progreso del usuario en una lección específica
model LessonProgress {
  id               String  @id @default(cuid())
  courseProgressId String
  lessonId         String  // Sanity lesson _id
  completed        Boolean @default(false)
  completedAt      DateTime?
  watchedSeconds   Int     @default(0) // Segundos de video vistos
  lastPosition     Int     @default(0) // Posición de reproducción para continuar

  // Relaciones
  courseProgress CourseProgress @relation(fields: [courseProgressId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([courseProgressId, lessonId])
  @@index([courseProgressId])
  @@map("lesson_progress")
}

// ============================================
// BOUNDED CONTEXT: Membership Credits
// ============================================

enum CreditReason {
  MONTHLY_GRANT     // Créditos mensuales de suscripción
  PROMO_GRANT       // Créditos promocionales
  ADMIN_ADJUSTMENT  // Ajuste manual por admin
  REDEEM            // Canje por reserva
  REFUND            // Devolución por cancelación
}

enum PerkAllocationStatus {
  PENDING      // Asignado pero no entregado
  DELIVERED    // Entregado al usuario
  UNAVAILABLE  // No disponible (cupos agotados)
}

model CreditsLedger {
  id             String       @id @default(cuid())
  userId         String

  // Detalles de la transacción
  amount         Int          // +1 para otorgar, -1 para canjear
  reason         CreditReason

  // Referencias
  subscriptionId String?      // Suscripción origen (para grants)
  bookingId      String?      // Reserva asociada (para redemptions)
  referenceId    String?      // Referencia genérica (código promo, nota admin, etc.)

  // Expiración (solo para grants)
  expiresAt      DateTime?    // Cuando expira este crédito

  // Auditoría
  notes          String?      @db.Text
  createdBy      String?      // userId del admin para ajustes manuales

  // Relaciones
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt      DateTime     @default(now())

  @@index([userId])
  @@index([userId, expiresAt])
  @@index([subscriptionId])
  @@index([bookingId])
  @@map("credits_ledger")
}

// ============================================
// BOUNDED CONTEXT: Event Perks
// ============================================

// Asignación de perks a bookings de eventos
model PerkAllocation {
  id           String               @id @default(cuid())
  eventId      String               // Sanity event _id
  bookingId    String
  userId       String

  // Perk info (desnormalizado desde Sanity para display/auditoría)
  perkType     String               // 'recording' | 'transcript' | 'workbook' | etc.
  perkTitle    String
  perkIndex    Int                  // Índice en el array de perks (para ordenar)

  // Estado
  status       PerkAllocationStatus @default(PENDING)

  // Info de entrega
  deliveredAt  DateTime?
  deliveredBy  String?              // Admin userId que entregó
  assetUrl     String?              // URL del recurso entregado (puede diferir de Sanity)

  // Metadata adicional
  metadata     Json?                // Datos adicionales (ej: plan prioritario usado)

  // Timestamps
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  // Relaciones
  user         User                 @relation(fields: [userId], references: [id])

  @@unique([bookingId, perkType])   // Una asignación por tipo de perk por booking
  @@index([eventId])
  @@index([userId])
  @@index([eventId, perkType, status])
  @@map("perk_allocations")
}

// ============================================
// BOUNDED CONTEXT: Audit & Logging
// ============================================

// Registro de acciones administrativas para trazabilidad
model AuditLog {
  id         String   @id @default(cuid())
  actorId    String   // userId del admin que ejecutó la acción
  actorEmail String   // Email para referencia rápida

  entityType String   // "booking" | "order" | "subscription" | "user"
  entityId   String
  action     String   // "cancel" | "reschedule" | "refund" | "status_change" | "complete" | "no_show"

  before     Json?    // Estado anterior (snapshot)
  after      Json?    // Estado posterior (snapshot)
  reason     String?  // Motivo proporcionado por el admin
  metadata   Json?    // Datos adicionales (IP, user agent, etc.)

  createdAt  DateTime @default(now())

  @@index([entityType, entityId])
  @@index([actorId])
  @@index([createdAt])
  @@map("audit_logs")
}

// Registro de emails enviados para trazabilidad y debugging
model EmailLog {
  id                String   @id @default(cuid())
  to                String   // Email destinatario
  template          String   // "booking_confirmation" | "booking_cancelled" | "booking_rescheduled" | etc.
  subject           String?  // Asunto del email

  entityType        String?  // "booking" | "order" | "subscription"
  entityId          String?

  status            String   @default("PENDING") // "PENDING" | "SENT" | "FAILED"
  providerMessageId String?  // ID de Resend
  errorMessage      String?  // Mensaje de error si falló

  metadata          Json?    // Datos adicionales del email

  sentAt            DateTime?
  createdAt         DateTime @default(now())

  @@index([to])
  @@index([entityType, entityId])
  @@index([status])
  @@map("email_logs")
}

// ============================================
// BOUNDED CONTEXT: Academia - Quizzes & Certificates
// ============================================

// Intento de quiz por un usuario
model QuizAttempt {
  id           String   @id @default(cuid())
  userId       String
  quizId       String   // Sanity quiz _id
  courseId     String   // Sanity course _id
  lessonId     String?  // Sanity lesson _id (null para examen final del curso)

  // Resultados
  score        Decimal  @db.Decimal(5, 2) // Porcentaje de aciertos
  totalPoints  Int      // Puntos totales posibles
  earnedPoints Int      // Puntos obtenidos
  passed       Boolean  // Si aprobó según el passingScore del quiz

  // Respuestas guardadas como JSON
  // Formato: [{ questionIndex, questionText, selectedAnswer, correctAnswer, correct, points }]
  answers      Json

  // Tiempos
  startedAt    DateTime @default(now())
  completedAt  DateTime
  timeSpent    Int      // Segundos que tardó en completar

  // Relaciones
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([userId, quizId])
  @@index([courseId])
  @@index([lessonId])
  @@map("quiz_attempts")
}

// Certificado emitido a un usuario por completar un curso
model Certificate {
  id                String    @id @default(cuid())
  userId            String
  courseId          String    // Sanity course _id
  courseName        String    // Nombre del curso (desnormalizado para display)

  // Datos del certificado
  certificateNumber String    @unique  // Formato: CERT-YYYYMMDD-XXXXXX
  studentName       String    // Nombre del estudiante al momento de emisión
  issuedAt          DateTime  @default(now())
  validUntil        DateTime? // null = perpetuo (sin vencimiento)

  // PDF generado (cache opcional)
  pdfUrl            String?   // URL de Vercel Blob si se cacheó
  pdfGeneratedAt    DateTime? // Cuándo se generó el PDF cacheado

  // Metadata
  quizScore         Decimal?  @db.Decimal(5, 2) // Puntaje del examen final si aplica
  courseHours       Int?      // Horas del curso al momento de emisión

  // Relaciones
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([userId, courseId])
  @@index([userId])
  @@index([courseId])
  @@index([certificateNumber])
  @@map("certificates")
}
